**local runner** mirrors the GitHub Actions workflow, tuned for sandbox conventions:  

- **`.bitshell`** â†’ wrapper scripts you can execute in PowerShell (theyâ€™ll look like `.ps1` but with your naming convention).  
- **`.ing`** â†’ configuration payloads (YAML/JSONâ€‘like) that the runner consumes.  

---

## ğŸ“‚ File layout
```
/ops
  â”œâ”€ runner.bitshell
  â”œâ”€ configs
  â”‚    â”œâ”€ build_pipeline.ing
  â”‚    â”œâ”€ wasm_contracts.ing
  â”‚    â””â”€ streaming.ing
```

---

## âš¡ runner.bitshell
This is your PowerShell runner, renamed with `.bitshell` extension. It reads `.ing` payloads and executes the same steps as your GitHub Action.

```powershell
# File: ops/runner.bitshell
param(
  [string]$Config = "ops/configs/build_pipeline.ing"
)

Write-Host "=== Windows-of-Death Local Runner ==="
Write-Host "Loading config from $Config"

# Parse .ing payload (YAML/JSON hybrid)
$config = Get-Content $Config | ConvertFrom-Json

# Step 1: Git sync
if ($config.steps -contains "git_sync") {
  Write-Host "[SYNC] Pulling latest from remote..."
  git pull origin main
}

# Step 2: WASM contracts
if ($config.steps -contains "build_wasm") {
  Write-Host "[BUILD] Compiling WASM contracts..."
  pushd wasm/contracts
  cargo build --release --target wasm32-unknown-unknown
  popd
}

# Step 3: ALN batch generator
if ($config.steps -contains "generate_assets") {
  Write-Host "[ALN] Running batch generator..."
  aln run generate_assets `
    --input registry/assets.yml `
    --output data/ledger/placements.ndjson `
    --seed "session:$(Get-Date -Format yyyyMMddHHmmss)"
}

# Step 4: Audit logs
if ($config.steps -contains "audit") {
  $log = "logs/actions/local_runner.log"
  "$(Get-Date -Format o) | Runner executed with config $Config" | Add-Content $log
  Write-Host "[LOG] Audit entry written to $log"
}
```

---

## ğŸ—‚ï¸ build_pipeline.ing
This is the configuration payload that defines what the runner does.  
(Think of it as the local equivalent of your GitHub Actions YAML.)

```json
{
  "name": "Local Swarmnet Build",
  "steps": [
    "git_sync",
    "build_wasm",
    "generate_assets",
    "audit"
  ],
  "policies": {
    "require_actor": true,
    "log_sink": "logs/actions/local_runner.log"
  }
}
```

---

## ğŸ—‚ï¸ wasm_contracts.ing
```json
{
  "contracts": [
    {
      "id": "wod.asset.place.v1",
      "path": "approvals/place_v1.wasm",
      "enforce": ["checksum", "occlusion", "provenance"]
    }
  ]
}
```

---

## ğŸ—‚ï¸ streaming.ing
```json
{
  "streaming": {
    "budgets": {
      "max_realizations_per_500ms": 3,
      "max_animation_blends_per_500ms": 5
    },
    "occlusion": {
      "require_geometry_blocking": true,
      "defer_ms_min": 50,
      "defer_ms_max": 250
    },
    "prefetch": {
      "radius_cells": 2,
      "heuristic": "intent+velocity+camera"
    }
  }
}
```

---

## ğŸ”‘ How this works
- You run:  
  ```powershell
  .\ops\runner.bitshell -Config ops/configs/build_pipeline.ing
  ```
- The runner reads the `.ing` payload, executes steps in order, and writes audit logs.  
- You can swap configs (`wasm_contracts.ing`, `streaming.ing`) to test different policies without touching the runner.  
- This mirrors your **remote GitHub workflow**, but gives you **local reproducibility** in your sandbox.  

---
